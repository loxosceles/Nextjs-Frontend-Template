# Architecture Overview

## Stack

```
frontend/        Next.js App Router — static export (output: 'export')
infrastructure/  AWS CDK — CloudFront + S3 (OAC)
```

## Deployment Architecture

```
S3 Bucket (private, OAC)
    ↑ origin
CloudFront Distribution
    ↑ HTTPS
Browser
```

Static files are built locally or in CodeBuild, uploaded to S3, and served via CloudFront.
No SSR — all pages are pre-rendered at build time.

## Configuration Flow

```
Bootstrap (pre-infra)          Runtime (post-infra)
─────────────────────          ────────────────────
.env.{stage} (local)    →      SSM Parameter Store
CI env vars             →      /{project}/{stage}/cloudfront-domain
        ↓                      /{project}/{stage}/bucket-name
EnvironmentManager             /{project}/{stage}/cloudfront-distribution-id
        ↓
CDK synth → deploy
        ↓
Writes SSM outputs
```

## Monorepo Structure

```
nextjs-frontend-template/
├── frontend/                    # pnpm workspace
│   ├── app/                     # Next.js App Router
│   ├── components/
│   ├── hooks/
│   ├── lib/
│   └── shared/                  # Types, constants
│
├── infrastructure/              # pnpm workspace
│   ├── bin/app.ts               # CDK entry — reads ENVIRONMENT, calls EnvironmentManager
│   ├── configs/
│   │   ├── project.config.ts    # PROJECT_NAME token — only file setup.sh modifies
│   │   └── stack-config.ts      # Bucket/stack names derived from PROJECT_NAME
│   ├── lib/
│   │   ├── stacks/web-stack.ts  # S3 + CloudFront + SSM outputs
│   │   ├── stacks/pipeline-stack.ts  # CodePipeline + CodeBuild + OIDC role
│   │   ├── infra.ts             # 1-tier CLI (deploy, deploy:pipeline, publish, ssm-upload, github-vars, setup-oidc, synth, destroy)
│   │   └── core/
│   │       └── environment-manager.ts  # Loads bootstrap config, centralizes all process.env access
│   └── test/
│
├── .devcontainer/               # Generated by setup.sh
├── .github/workflows/           # lint, test, versioning, trigger-pipeline
├── .vscode/                     # settings + mcp (placeholder values)
├── .amazonq/                    # mcp + rules
└── setup.sh                     # Bootstrap script (curl | bash)
```

## CLI Architecture

1-tier pattern — single entry point for all infrastructure operations:

```
pnpm deploy:dev             → ENVIRONMENT=dev ts-node infrastructure/lib/infra.ts deploy
pnpm deploy:pipeline:dev    → ENVIRONMENT=dev ts-node infrastructure/lib/infra.ts deploy:pipeline
pnpm deploy:pipeline:prod   → ENVIRONMENT=prod ts-node infrastructure/lib/infra.ts deploy:pipeline
```

Commands: `deploy` (blocked for prod) | `deploy:pipeline` | `publish` | `ssm-upload` | `github-vars` | `setup-oidc` | `synth` | `destroy` (blocked for prod)

All `process.env` access is centralized in `EnvironmentManager`:
- `EnvironmentManager.getStage()` — reads `ENVIRONMENT`, validates against supported stages
- `load(target)` — per-stage AND per-target validation (`web` requires domain/cert for prod; `pipeline` does not)

## Branch Strategy

```
feature/* → dev    lint + test on PR; CodePipeline dev on merge
dev → main         lint + test on PR; version-and-tag → CodePipeline prod on merge
```

PRs to `main` require a `major`, `minor`, or `patch` label for semver bump.
